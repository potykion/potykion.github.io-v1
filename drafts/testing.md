# Полный гайд по тестированию

## Цель

Собрать все знания по тестированию в одном месте, чтобы облегчить жизнь себе и другим разрабам

---

## Тестирование это про что?

**Тестирование** - автоматический запуск и проверка кода 

А теперь подробнее про каждый пункт:

- **Автоматический** - без ручного ввода; запуск запускается в одну кнопку или вовсе автоматически, напр. на ci при очередном коммите
- **Запуск** - код легко можно запустить, без большого количества делодвижений
- **Проверка** - для одно и того же ввода код должен выдавать один и тот же результат

### Зачем нужно?

Для того чтобы быть уверенным:

- что написанный функционал работает
- что при внесении изменений система не сломалась (так называемая регрессия/smoke-test)
- что сторонний код работает
- и тд

Как ни парадоксально, для поиска багов автоматическое тестирование не сильно подходит. По моему опыту ручное тестирование баги отлавливает гораздо лучше

---

## Первый тест
В качестве первого теста напишем и протестируем функцию суммирования

Но сначала надо поставить тестовый фреймворк - pytest:

```
pip install pytest
```

*Есть куча разных фреймворков и способов тестирования, всех их мы разберем в процессе, но для начала воспользуемся либой pytest, которая является индустриальным стандартом для тестирования + с ней легко работать*

Напишем код суммирования:

```python
# main.py

def sum_nums(*nums):
  sum_ = 0

  for num in nums:
      sum_ += num

  return sum_
```

Напишем тестик:

```python
# test_main.py

from main import sum_nums

def test_sum_nums():
  nums = [1, 2, 3]

  sum_ = sum_nums(*nums)

  assert sum_ == 6
```

Запустим тест простой командой - `pytest`:

```
> pytest
===== test session starts =====
platform win32 -- Python 3.9.0, pytest-7.1.1, pluggy-1.0.0
rootdir: C:\Users\potyk\PycharmProjects\potyk-io-draft
collected 1 item                                                                                                                                                    

test_main.py .                                                                                                                                               [100%] 

===== 1 passed in 0.02s =====
```

Ура, все прошло успешно!

---

## Краткий обзор тестовых фреймворков

### unittest

- Тестовый фреймворк, поставляемый вместе с Python
- Я с ним особо не работал, но это очень похоже на Django - далее будет про него

### doctest

- Тоже поставляется из коробки
- Суть в том, что можно писать тесты в docstring класса/метода:

```python
def sum_nums(*nums):
  """
  >>> sum_nums(1, 2, 3)
  6
  """
  
  sum_ = 0

  for num in nums:
      sum_ += num

  return sum_

```

- Запускать удобнее всего через PyCharm:

![[Pasted image 20220406173732.png]]

### pytest

- Индустриальный стандарт
- Легко писать тесты - все на `assert`-ах
- Есть куча плагинов, напр. для django, для параллельного запуска, для подгрузки переменных окружения и тд

### Django

- По базе тесты пишутся как стандартные unit-тесты:

```python
from django.test import TestCase

class TestView(TestCase):
  def test_call(self):
    resp = self.client.get(reverse('view-url')) 

    self.assertEqual(resp.data, {...})
```

- Можно писать проще, используя pytest-django

А теперь про каждый подробнее:

## [doctest](https://docs.python.org/3/library/doctest.html)
- Поставляется сразу с Python

- Принцип работы - аналогично Python консоли: написали какой-то код -> получили вывод -> копируем и вставляем в докстринг -> доктест готов

```
Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> 1 + 1
2
```

### Пример
- Удобно для теста утилиток:

```python
def try_int(str_: Optional[str], none_on_err = False) -> Union[int, None, str]:  
    """  
    >>> try_int('1')  
    1 
    >>> try_int("sam")  
    'sam'
    >>> try_int('sam', none_on_err=True) is None  
    True 
    """ 
  
    try:  
        return int(str_)  
    except (TypeError, ValueError):  
        if none_on_err:  
            return None  
        else:  
            return str_
 ```


- Пример выше хорошо показывает как писать доктесты:
    - Проверяемая строка должна быть в `'`-кавычках
    - Проверку на `None` лучше делать через `is None`, тк `None` в терминале не выводится

 - Еще раз акцентирую внимание на консольном выводе:
 
```python
>>> import datetime as dt
>>> dt.datetime(2022, 4, 8)
datetime.datetime(2022, 4, 8, 0, 0)
```

- Независимо от того, как произодится импорт, вывод в консоли может отличаться

### Скип для демонстрации
- Удобно описывать как пользоваться кодом
- При этом можно не запускать сами тесты, используя `# doctest: +SKIP`:

```python
def sum_items(items: List[Item]):
    """
    >>> item_1 = Item.objects.create(price=10) # doctest: +SKIP
    >>> item_2 = Item.objects.create(price=20) # doctest: +SKIP
    >>> sum_items([item_1, item_2]) # doctest: +SKIP
    30
    """
```

- В примере выше создаются django-сущности, которые сохраняются в бд
- Стучаться в базу в доктестах не стоит (аналогично любые другие действия с сайд-эффектами делать в доктестах не стоит), так что используем `# doctest: +SKIP` для демострации вызова функции

### Многострочный тест
- Не забываем правило "Что в интерпретаторе, то и в доктесте"
- Таким образом для многострочного кода (напр. декларация функций, классов) используем `...`:
```python
def sum_prices(*items):
    """
    >>> class Item:
    ...   def __init__(self, price):
    ...     self.price = price
    ...
    >>> item_1 = Item(100)
    >>> item_2 = Item(200)
    >>> sum_prices(item_1, item_2)
    300
    """
    return sum(i.price for i in items)
```

### Тест исключений
- При возникновении исключений Python вываливает трейсбек:
```
Traceback (most recent call last):
      File "C:\Users\potyk\AppData\Local\JetBrains\Toolbox\apps\PyCharm-P\ch-0\213.7172.26\plugins\python\helpers\pycharm\docrunner.py", line 138, in __run
        exec(compile(example.source, filename, "single",
      File "<doctest err[0]>", line 1, in <module>
        err()
      File "C:/Users/potyk/PycharmProjects/potyk-io-draft/main.py", line 19, in err
        assert False
    AssertionError

```
- Такое в доктест не напишешь - это будет нестабильно работать не только у тебя, но и у других
- На помощь снова приходит `...`:
```python
def err():
    """
    >>> err()
    Traceback (most recent call last):
    ...
    AssertionError
    """
    assert False
```
- `...`  обозначают, что в выводе что-то есть, но нас это не особо интересует - это что-то типа паттерн матчинга


## pytest

- pytest хорош
- Хорош простотой
```python
def test_sum():
    nums = [1, 2, 3]

    sum_ = sum(nums)

    assert sum_ == 6
```
- Как видно тест - это простая функция, проверка осуществляется с помощью ключевого слова `assert`
- Хорош как запускатор тестов:
    - Запуск тестов одной командой - `pytest`
     - Тестирует все что начинается со слова `test`
 - Хорош в своей конфигурируемости
     - Конфигурируется как через cli, так и через файл
     - Поддержка нескольких файлов конфигурации: pytest.ini, setup.cfg, и тд
     - Куча плагинов на все случаи жизни: 
         - Для каждого популярного веб-фреймворка есть pytest-плагин: pytest-django, pytest-flask; pytest-aiohttp; fastapi написан уже с рассчетом на pytest
         - Плагин для коверейджа - отчет о том, как тесты покрывают код
         - Плагин для переменных среды - чтобы конфигурировать приложение с тестовыми данными, напр. с тестовым подключением к бд
         - И [многие другие](https://github.com/augustogoulart/awesome-pytest)

### Фикстуры
- Фикстуры - это что-то типа ioc-контейнера
- Суть в том, что ты отпределяешь фикстуру - функцию, которая отдает какие-нибудь данные, - и ее можно использовать в любом тесте, передав как параметр функции:
```python
import pytest

@pytest.fixture()
def order():
    return {'items': [{'price': 100, 'id': 1}, {'price': 200, 'id': 2}]}

def test_sum_prices(order):
    sum_ = sum([oi['price'] for oi in order['items']])

    assert sum_ == 300

```
- Фикстуры можно использовать как setup-teardown механизм - то есть логику которая выполняется перед и после запуска тестов:
- Для этого используем `yield`:
```python
@pytest.fixture()
def file_data():
    with open('test_file.txt') as f:
        yield f.read()

def test_file_data(file_data):
    ...

```
- Здесь при обращении к фикстуре произойдет чтение из файла, а после выполнения теста произойдет закрытие файла
- Удобно использовать для создания и закрытия тестовых соединений к бд:
```python
@pytest.fixture()  
async def async_db_connection(loop: AbstractEventLoop) -> SAConnection:  
    async with create_engine(DB_URL) as engine:  
        async with engine.acquire() as connection:  
            yield connection
```
- Пример выше создает соединение к бд с помощью aiopg; после выполнения теста подключение к бд закрывается

#### Переиспользование фикстур - `conftest.py`
- Фикстуры, которые используются в нескольких тестовых файлах/модулях, можно вынести в один файл - `conftest.py`
- Его действие распространяется на пакет - то есть нельзя создать `conftest.py` в одной директории, а тесты писать в другой *невложенной* директории
- Но все выносить туда не надо, иначе получится что есть conftest.py в корневой директории, затем есть conftest.py на уровне пакета, и чтобы понять что за фикстура используется в тесте, нужно залесть в кучу разных мест - ну тут как с наследованием - оно хорошо в умеренных количествах
- Для создания сущностей с большой вложенностью лучше использовать `factoryboy` - о нем погорим далее


### Запуск тестов на разных данных - `pytest.mark.parametrize`
- Чтобы запустить один и тот же тест несколько раз для разных данных - можно использовать декоратор `pytest.mark.parametrize`:
```python
@pytest.mark.parametrize(  
    'raw_phone, valid_phone',  
    [  
        ('8 985 248 90-52', '79852489052'),  
        ('+7 985 248 90-52', '79852489052'),  
        ('+7 (985) 248 90-52', '79852489052')  
    ]  
)  
def test_sanitize_phone(raw_phone, valid_phone):  
    assert sanitize_phone(raw_phone) == valid_phone
```
- В декораторе указываем передаваемые параметры в виде строки или списка строк, а также примеры параметров - эти параметры будут переданы в тестовую функцию, и все это трансформируется в N-тесто в, каждый со своими данными:
![[Pasted image 20220414150125.png]]



## Django
- Django поставляется со своим тестовым фреймворком
- Он очень похож на unittest: тесты нужно писать в виде классов, ассерты вызывомами функций типа `self.assertEquals`
- Можно жить без pytest-django - разница примерно такая же что и между java и kotlin - pytest-django дает лишь сахар
- При тестировании моделек автоматически создается тестовая база
- `from django.test import TestCase` - класс, от которого необходимо наследовать все тесты
### Тесты DRF
- `from rest_framework.test import APITestCase` - наследуем все тесты от этого класса

---

## Как писать?
Хороший тест состоит из 3 частей: 
1. инициализация данных
2. выполнение действий (запуск фичи)
3. проверка

Как и код, чем меньше тест - тем лучше, в идеале 2-3 строчечьки.

```python
def test_sum():
	nums = [1, 2, 3]

	sum_ = sum(nums)

	assert sum_ == 6
```

## Как запускать
1. pytest - ставим pytest: `pip install pytest`, запускаем одной командой: `pytest` - и все: команда сама прошерстит весь код на предмет функций и классов, начинающихся со слов `test_`
2. Фреймворк депенденд вей: напр. `python manage.py test --keepdb` для django
3. В IDE

**Тестировать лень.** Если необходимо протестировать большой юзкейс, то очень неохота создавать миллион сущностей, проставлять им определенные поля, создавать миллион моков, потом писать кучу ассертов.

**ORM - это круто.** Хорошая ORM (Django, GAE NDB) предоставляет утилиты для тестирования, не нужно самостоятельно писать утилиты для моканья соединений, писать репозитории.

**Тестовый фреймворк не важен.** Стандартом для тестирования сейчас является pytest. Но тесты можно писать и без использования pytest. Напр. стандартный Django `TestCase` с его `self.assertEquals`, писать ненамного сложнее чем pytest-assertы. Pytest лишь предоставляет плюшки.

Более того, в django есть удобные ассерты, которых нет в pytest: напр. `assertHtmlEqual` - для проверки html без учета форматирования,  `assertCountEquals` - для проверки списков без учета порядка. Конечно можно поставить pytest-django и брать лучшее из двух миров.

**Pytest-фикстуры - игрушка дьявола.** Очень неудобно когда есть фикстуры, определенные в conftest, и связанные с сущностями. Неудобно в том плане, что тебе нужно постоянно прыгать между фикстурами, а фикстуры могут быть размазаны по куче файлов, и тогда прыгать надо еще больше.

По ощущениям фикстуры решает проблемы фреймворков, которые лишены нормальных фич и нормальных тестовых утилит. Если в фреймворке нет орм, то нужно писать код, так чтобы его можно было замокать, и фикстуры хорошо помогают в том, чтобы хорошо заполнить моки. Так с помощью фикстур хорошо создавать соединения к тестовым базам данных. Но в django этот функционал есть из коробки.

**Factoryboy прекрасен.** Альтернатива фикстурам - factoryboy-фабрики. Создавая одну сущность, под капотом создадутся все прилегающие сущности. Этот функционал реализуется и через фикстуры, но в случае фабрик гораздо легче изменять вложенные сущности.

**Тесты нужно запускать всегда.** Если тесты не запускать, то рано или поздно большинство тестов не будет работать. Необходимо автоматизировать их запуск, используя pre-commit или ci.

**Доктесты хороши в своей нише.** Доктесты отлично подходят при тестировании утилиток, но совершенно не подходят для тестирования юзкейсов - нет доступа к фикстурам/фабрикам. Еще хорошо использовать доктесты для демонстрации функционала, не запуская их - в этом помогает `# doctest:+SKIP`.

**Применение моков.** Если код делает запрос в апишку, то в тестах реального запроса не должно уходить - тк тема нестабильная. Тесты должны работать без интернета (вообще для разработки интернет не особо нужен, разве что в таск трекер заходить). Можно замокать вызовы апи - то есть при выхове апи будет возвращаться те данные, которые ты укажешь. Использовать для этого можно стандартный пакет `mock`, так и специальные library-specific пакеты, типа `responses`. 

**Моки и даты.** Аналогичная ситуация с датами. Получение текущей даты - это не чистая функция - для одного и того же ввода, она выдает разные выводы. Для тестов нам нужна определенность - чтобы возвращалась та дата, которую мы указали - для этого хорошо подходит пакет - `freezegun`.

**Моки и юзкейсы.** Юзкейсы обычно вызывают несколько смежных методов. А тк методы мы уже протестировали, можно замокать их вызывовы при тесте юзкейсов.



